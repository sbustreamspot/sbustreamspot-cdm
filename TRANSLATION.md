# CDM to StreamSpot Translation Heuristics

## Contents

   1. [StreamSpot format]()
   2. [CDM format]()
      1. [CDM events]()
      2. [CDM subjects, objects and principals]()
      3. [CDM simple edges]()
   3. [Combining CDM records into a StreamSpot edge]()
   4. [Assigning a graph ID to each StreamSpot edge]()

# Converting from CDM to StreamSpot Format

## StreamSpot Format

StreamSpot takes input as a TSV file containing on each line the following fields:
```
source_id source_type destination_id destination_type edge_type graph_id
```
The fields are data-typed as follows:
   * `source_id` and `destination_id`: Integer greater than 1 (0 stands for NA, like anonymous memory maps).
   * `source_type`, `destination_type`, `edge_type`: Single byte (we've been using ASCII characters so far).
   * `graph_id`: Integer greater than 0.

An example record in StreamSpot's format is: `4    a    5    c    p    0`.

The data it currently uses is available [here](https://github.com/sbustreamspot/sbustreamspot-data).

## CDM Format

We are using the [CDM 12 schema](https://git.tc.bbn.com/bbn/ta3-serialization-schema/blob/master/avro/CDM12.avdl).

### CDM Events

CDM-formatted JSON data contains events in the following format:
```
{"datum":{"com.bbn.tc.schema.avro.Event":{"uuid":"=ÖmÖä<8f><99>\u0015øNe¢÷<84>\f®ïC<94>é®<85>\u0001j\u0000 Ç¹s\u001AÓï","sequence":65362,"type":"EVENT_OPEN","threadId":28005,"source":"SOURCE_LINUX_AUDIT_TRACE","timestampMicros":{"long":1450217860803},"name":null,"parameters":null,"location":null,"size":null,"programPoint":null,"properties":{"map":{"eventId":"65362"}}}},"CDMVersion":"12"}
```

Unlike edges, CDM events are not self-contained: the only thing available is the event type (`EVENT_OPEN` in the example above). The rest of the metadata is contained in other non-event records occuring *both previously and after* the event record in the CDM data. Let's look at these records now.

### CDM Subjects, Objects and Principals

Subjects correspond to entities like processes, threads and units.
```
{"datum":{"com.bbn.tc.schema.avro.Subject":{"uuid":"~#<92>Å7<9f>ÜUèÓ\ryEQ¬¾\"Ëõ]<96>xb3#}UcÏåÿ<90>","type":"SUBJECT_PROCESS","pid":28005,"ppid":27999,"source":"SOURCE_LINUX_AUDIT_TRACE","startTimestampMicros":null,"unitId":{"int":0},"endTimestampMicros":null,"cmdLine":null,"importedLibraries":null,"exportedLibraries":null,"pInfo":null,"properties":{"map":{"uid":"0","programName":"sudo","group":"1003"}}}},"CDMVersion":"12"}
```

Objects correspond to entities like files, sockets or memory addresses.
```
{"datum":{"com.bbn.tc.schema.avro.FileObject":{"uuid":"Ý<9c>¨©<96>°<98>\r\u0012p <87>Í¦¤õ\u0005L<91>D<8c>Â<96><97>\\;\u0011µbW<82>S","baseObject":{"source":"SOURCE_LINUX_AUDIT_TRACE","permission":null,"lastTimestampMicros":null,"properties":null},"url":"file:///etc/login.defs","isPipe":false,"version":0,"size":null}},"CDMVersion":"12"}
```

Principals correspond to entities like local and remote users, which StreamSpot doesn't use as of now.
```
{"datum":{"com.bbn.tc.schema.avro.Principal":{"uuid":"\u001DÕ\u0019.ÖÑ8,¸ïB:»lò\u0011<96>?3Æ\rÌYï\u001C\u0013É7²Õðç","type":"PRINCIPAL_LOCAL","userId":0,"groupIds":[1003],"source":"SOURCE_LINUX_AUDIT_TRACE","properties":{"map":{"euid":"0","egid":"1003"}}}},"CDMVersion":"12"}
```

All 3 of the above CDM records appeared before the event record in the file.

### CDM Simple Edges

CDM edges are what connect events to subjects, objects and principals. The CDM edge types we care about are:
   * `EDGE_EVENT_ISGENERATEDBY_SUBJECT`: When an event is generated by a process/thread/unit.
   * `EDGE_EVENT_AFFECTS_*`: When an event writes to a file/registry/socket or forks a process.
   * `EDGE_*_AFFECTS_EVENT`: When an event reads from a file/registry/socket.

The entire CDM edge type list is [here](https://git.tc.bbn.com/bbn/ta3-serialization-schema/blob/master/avro/CDM12.avdl#L225).

Continuing the example from above, the following CDM edge records *following* the event provide the metadata we need:
   * `{"datum":{"com.bbn.tc.schema.avro.SimpleEdge":{"fromUuid":"=ÖmÖä<8f><99>\u0015øNe¢÷<84>\f®ïC<94>é®<85>\u0001j\u0000 Ç¹s\u001AÓï","toUuid":"Ý<9c>¨©<96>°<98>\r\u0012p <87>Í¦¤õ\u0005L<91>D<8c>Â<96><97>\\;\u0011µbW<82>S","type":"EDGE_FILE_AFFECTS_EVENT","timestamp":1450217860803,"properties":null}},"CDMVersion":"12"}`
   
   This tells us that a specific file object (identified by the UUID) was read during the event; so it provides us the destination type. By following this CDM edge to the object UUID, we can find out the destination ID (by mapping the filename to an ID).

   * `{"datum":{"com.bbn.tc.schema.avro.SimpleEdge":{"fromUuid":"=ÖmÖä<8f><99>\u0015øNe¢÷<84>\f®ïC<94>é®<85>\u0001j\u0000 Ç¹s\u001AÓï","toUuid":"~#<92>Å7<9f>ÜUèÓ\ryEQ¬¾\"Ëõ]<96>xb3#}UcÏåÿ<90>","type":"EDGE_EVENT_ISGENERATEDBY_SUBJECT","timestamp":1450217860803,"properties":null}},"CDMVersion":"12"}`
   
   This tells us which process/thread/unit subject (identified by the UUID) generated the event. By following this edge to the subject UUID, we can find out the source type and source ID.

## Combining CDM records into a StreamSpot edge

By reading all the records *preceding* the event record and *following* the event record *until the next event record*, we can collect all the metadata needed to (almost) construct a StreamSpot edge (for the example above):
   * Edge type: `EVENT_OPEN`, *directly* from the event record.
   * Source type: `SUBJECT_PROCESS`, from a CDM record *following* the event record.
   * Source ID: `"pid":28005`, from a CDM record *preceding* the event record.
   * Destination type: `EDGE_FILE_AFFECTS_EVENT`, from a CDM record *following* the event record.
   * Destination ID: `"url":"file:///etc/login.defs"`, from a CDM record *preceding* the event record.
     Note that the source and destination may need to be swapped here since the file is read and information flows to the process.

We still need to apply the following transformations:
   * Map source, destination and type names to single bytes: this can be done using the schema.
   * Map each destination ID (filename, memory address, URL) to an integer index.

We will maintain these maps in memory. What's left now is assigning graph ID's.

## Assigning a graph ID to each StreamSpot edge

We maintain a mapping from process/unit/thread ID to graph ID. Subsequent rules assume processes. The rules of graph ID assignment are:
   * Two process ID's will have the same graph ID if one was forked from the other.
   * Two process ID's will have different graph ID's if neither was forked from the other.
   * Two process ID's will have different graph ID's if the parent forked then exec'd.
   * Graph ID's start from 0, so the first process is assigned graph ID 0.

The mechanics will work as follows:
   * When a new `SUBJECT_PROCESS` CDM record is read:
      * Check if its `pid` already has an assigned graph ID. 
      * If a graph ID is already assigned to the `pid`, then continue. (*this case should not occur, ideally*)
      * If a graph ID is not assigned to the `pid`, then check if its `ppid` already has an assigned graph ID:
         * If a graph ID is assigned to the `ppid`, assign the same graph ID to the `pid`.
         * If a graph ID is not assigned to the `ppid`, assign the next available graph ID to the `pid`.
      * All subsequent events generated by this `pid` will use this assigned graph ID for the StreamSpot edge.
   * When a new `EVENT_EXECUTE` CDM record is read:
      * Note the `threadId` field of the event: this is the `pid` of the child process.
      * Assign the next available graph ID to this `pid`, replacing any existing assignment.
      * All subsequent events generated by this `pid` will use this assigned graph ID for the StreamSpot edge.
